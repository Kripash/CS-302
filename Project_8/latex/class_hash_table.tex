\hypertarget{class_hash_table}{}\subsection{Hash\+Table$<$ Data\+Type, Key\+Type $>$ Class Template Reference}
\label{class_hash_table}\index{Hash\+Table$<$ Data\+Type, Key\+Type $>$@{Hash\+Table$<$ Data\+Type, Key\+Type $>$}}
\subsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_hash_table_a103b09f30dbac0fe92fc2f1192feb0c1}{Hash\+Table} (int init\+Table\+Size)
\item 
\hyperlink{class_hash_table_a5da00f8a0dc9dc745675a96eac228049}{Hash\+Table} (const \hyperlink{class_hash_table}{Hash\+Table} \&other)
\item 
\hyperlink{class_hash_table}{Hash\+Table} \& \hyperlink{class_hash_table_add76a73a92b81a2d54c20078d4a76546}{operator=} (const \hyperlink{class_hash_table}{Hash\+Table} \&other)
\item 
\hyperlink{class_hash_table_ae25eb9c66b9bce8c9c04f18e22688a15}{$\sim$\+Hash\+Table} ()
\item 
void \hyperlink{class_hash_table_adc8f2be061729bdc5ecb171b54304e17}{insert} (const Data\+Type \&new\+Data\+Item)
\item 
bool \hyperlink{class_hash_table_a46d3f8ad70fd80dc7aa64f50676ef7a5}{remove} (const Key\+Type \&delete\+Key)
\item 
bool \hyperlink{class_hash_table_ad4ee3ff641daa330260a48de29492e66}{retrieve} (const Key\+Type \&search\+Key, Data\+Type \&return\+Item) const 
\item 
void \hyperlink{class_hash_table_a57f581334e35d45a8822c03edc0fcca6}{clear} ()
\item 
bool \hyperlink{class_hash_table_a101e211a7fca37cd90722e15df2fc571}{is\+Empty} () const 
\item 
void \hyperlink{class_hash_table_a8b875e57f71a5bbba394e42361fb9fb4}{show\+Structure} () const 
\item 
double {\bfseries standard\+Deviation} () const \hypertarget{class_hash_table_a4db2d920fd7c632f5b4b1bacd503bbf1}{}\label{class_hash_table_a4db2d920fd7c632f5b4b1bacd503bbf1}

\end{DoxyCompactItemize}
\subsubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_hash_table_a300302ed45228f07c21ad8bf1d852fdd}{copy\+Table} (const \hyperlink{class_hash_table}{Hash\+Table} \&source)
\end{DoxyCompactItemize}
\subsubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
int {\bfseries table\+Size}\hypertarget{class_hash_table_a5b2aa73ce05cee50154f418eab43530b}{}\label{class_hash_table_a5b2aa73ce05cee50154f418eab43530b}

\item 
\hyperlink{class_b_s_tree}{B\+S\+Tree}$<$ Data\+Type, Key\+Type $>$ $\ast$ {\bfseries data\+Table}\hypertarget{class_hash_table_a1bff814c04c4dd2f0db26f2387557006}{}\label{class_hash_table_a1bff814c04c4dd2f0db26f2387557006}

\end{DoxyCompactItemize}


\subsubsection{Constructor \& Destructor Documentation}
\index{Hash\+Table@{Hash\+Table}!Hash\+Table@{Hash\+Table}}
\index{Hash\+Table@{Hash\+Table}!Hash\+Table@{Hash\+Table}}
\paragraph[{\texorpdfstring{Hash\+Table(int init\+Table\+Size)}{HashTable(int initTableSize)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type , typename Key\+Type $>$ {\bf Hash\+Table}$<$ Data\+Type, Key\+Type $>$\+::{\bf Hash\+Table} (
\begin{DoxyParamCaption}
\item[{int}]{init\+Table\+Size}
\end{DoxyParamCaption}
)}\hypertarget{class_hash_table_a103b09f30dbac0fe92fc2f1192feb0c1}{}\label{class_hash_table_a103b09f30dbac0fe92fc2f1192feb0c1}
This function is the param constructor for the \hyperlink{class_hash_table}{Hash\+Table} class.

This function will set the table\+Size of the \hyperlink{class_hash_table}{Hash\+Table} equal to the integer parameter passed. This function will also create a data\+Table (array) of Binary Search Trees with the size of table\+Size.


\begin{DoxyParams}{Parameters}
{\em int} & init\+Table\+Size, which is the size of the \hyperlink{class_hash_table}{Hash\+Table} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
The Hashtable is empty and was just created or needs to be modified. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The \hyperlink{class_hash_table}{Hash\+Table} will be intialized to be the size of the integer parameter passed. 
\end{DoxyPostcond}
\index{Hash\+Table@{Hash\+Table}!Hash\+Table@{Hash\+Table}}
\index{Hash\+Table@{Hash\+Table}!Hash\+Table@{Hash\+Table}}
\paragraph[{\texorpdfstring{Hash\+Table(const Hash\+Table \&other)}{HashTable(const HashTable &other)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type , typename Key\+Type $>$ {\bf Hash\+Table}$<$ Data\+Type, Key\+Type $>$\+::{\bf Hash\+Table} (
\begin{DoxyParamCaption}
\item[{const {\bf Hash\+Table}$<$ Data\+Type, Key\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
)}\hypertarget{class_hash_table_a5da00f8a0dc9dc745675a96eac228049}{}\label{class_hash_table_a5da00f8a0dc9dc745675a96eac228049}
This function is the copy constructor for the \hyperlink{class_hash_table}{Hash\+Table} class.

This function will first call the copy\+Table function with other passed in as the parameter to create a copy of the other \hyperlink{class_hash_table}{Hash\+Table}.


\begin{DoxyParams}{Parameters}
{\em const} & Hash\+Table$<$\+Data\+Type, Key\+Type$>$\& other, which is the other \hyperlink{class_hash_table}{Hash\+Table} that is to be copied so that this object is the copy of the other./ \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
none 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
This function will create a copy of the parameter of \hyperlink{class_hash_table}{Hash\+Table}\& other and make the copy to this object. 
\end{DoxyPostcond}
\index{Hash\+Table@{Hash\+Table}!````~Hash\+Table@{$\sim$\+Hash\+Table}}
\index{````~Hash\+Table@{$\sim$\+Hash\+Table}!Hash\+Table@{Hash\+Table}}
\paragraph[{\texorpdfstring{$\sim$\+Hash\+Table()}{~HashTable()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type , typename Key\+Type $>$ {\bf Hash\+Table}$<$ Data\+Type, Key\+Type $>$\+::$\sim${\bf Hash\+Table} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_hash_table_ae25eb9c66b9bce8c9c04f18e22688a15}{}\label{class_hash_table_ae25eb9c66b9bce8c9c04f18e22688a15}
This function is the destructor for the \hyperlink{class_hash_table}{Hash\+Table} class.

This function will call the clear function to clear the data for the current object.


\begin{DoxyParams}{Parameters}
{\em none} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
A \hyperlink{class_hash_table}{Hash\+Table} to be cleared. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
This \hyperlink{class_hash_table}{Hash\+Table} will be cleared. 
\end{DoxyPostcond}


\subsubsection{Member Function Documentation}
\index{Hash\+Table@{Hash\+Table}!clear@{clear}}
\index{clear@{clear}!Hash\+Table@{Hash\+Table}}
\paragraph[{\texorpdfstring{clear()}{clear()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type , typename Key\+Type $>$ void {\bf Hash\+Table}$<$ Data\+Type, Key\+Type $>$\+::clear (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_hash_table_a57f581334e35d45a8822c03edc0fcca6}{}\label{class_hash_table_a57f581334e35d45a8822c03edc0fcca6}
This function is the clear for the \hyperlink{class_hash_table}{Hash\+Table} class.

This function will loop from index 0 to the size of the table\+Size. In this for loop, the function iterates through each index of the \hyperlink{class_hash_table}{Hash\+Table} and clears the object in the index. It does this by calling the clear function for each Binary Search Tree A\+DT within the index of the \hyperlink{class_hash_table}{Hash\+Table}.


\begin{DoxyParams}{Parameters}
{\em none} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
An \hyperlink{class_hash_table}{Hash\+Table} object. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
\hyperlink{class_hash_table}{Hash\+Table} will be cleared through dynamically memory allocation. 
\end{DoxyPostcond}
\index{Hash\+Table@{Hash\+Table}!copy\+Table@{copy\+Table}}
\index{copy\+Table@{copy\+Table}!Hash\+Table@{Hash\+Table}}
\paragraph[{\texorpdfstring{copy\+Table(const Hash\+Table \&source)}{copyTable(const HashTable &source)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type , typename Key\+Type $>$ void {\bf Hash\+Table}$<$ Data\+Type, Key\+Type $>$\+::copy\+Table (
\begin{DoxyParamCaption}
\item[{const {\bf Hash\+Table}$<$ Data\+Type, Key\+Type $>$ \&}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_hash_table_a300302ed45228f07c21ad8bf1d852fdd}{}\label{class_hash_table_a300302ed45228f07c21ad8bf1d852fdd}
This function is the copy\+Table function of the \hyperlink{class_hash_table}{Hash\+Table} class. The function sets table\+Size to the source\textquotesingle{}s table\+Size. The function then allocates memory to create an array of Binary Search Tree\textquotesingle{}s equal to the table\+Size. The function goes from index 0 to the table\+Size and copies the data of the source array index to the current index.


\begin{DoxyParams}{Parameters}
{\em const} & Hash\+Table$<$\+Data\+Type, Key\+Type$>$\& source, which is the other \hyperlink{class_hash_table}{Hash\+Table} to copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
None
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
None 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
This \hyperlink{class_hash_table}{Hash\+Table} will have the same data as the source \hyperlink{class_hash_table}{Hash\+Table}. 
\end{DoxyPostcond}
\index{Hash\+Table@{Hash\+Table}!insert@{insert}}
\index{insert@{insert}!Hash\+Table@{Hash\+Table}}
\paragraph[{\texorpdfstring{insert(const Data\+Type \&new\+Data\+Item)}{insert(const DataType &newDataItem)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type , typename Key\+Type $>$ void {\bf Hash\+Table}$<$ Data\+Type, Key\+Type $>$\+::insert (
\begin{DoxyParamCaption}
\item[{const Data\+Type \&}]{new\+Data\+Item}
\end{DoxyParamCaption}
)}\hypertarget{class_hash_table_adc8f2be061729bdc5ecb171b54304e17}{}\label{class_hash_table_adc8f2be061729bdc5ecb171b54304e17}
This function is the insert function for the \hyperlink{class_hash_table}{Hash\+Table} class, which inserts a new data\+Item into the \hyperlink{class_hash_table}{Hash\+Table}.

This function creates a local variable called index, and sets it to 0. Index is then set to the new\+Data\+Item\textquotesingle{}s function called hash with the data\+Item\textquotesingle{}s get\+Key with modulus size of table\+Size since we have to recircle back to the index of the table based on the bounds of the size of the \hyperlink{class_hash_table}{Hash\+Table}. The function then inserts the new\+Data\+Item to the index of \hyperlink{class_hash_table}{Hash\+Table} that we calculated.


\begin{DoxyParams}{Parameters}
{\em const} & Data\+Type\& new\+Data\+Item, which is the data\+Item passed by reference to be inserted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
A \hyperlink{class_hash_table}{Hash\+Table} object to be modified. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The new Data\+Item will be inserted into the \hyperlink{class_hash_table}{Hash\+Table} based on the index we calculate. 
\end{DoxyPostcond}
\index{Hash\+Table@{Hash\+Table}!is\+Empty@{is\+Empty}}
\index{is\+Empty@{is\+Empty}!Hash\+Table@{Hash\+Table}}
\paragraph[{\texorpdfstring{is\+Empty() const }{isEmpty() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type , typename Key\+Type $>$ bool {\bf Hash\+Table}$<$ Data\+Type, Key\+Type $>$\+::is\+Empty (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_hash_table_a101e211a7fca37cd90722e15df2fc571}{}\label{class_hash_table_a101e211a7fca37cd90722e15df2fc571}
This function is the is\+Empty function for the \hyperlink{class_hash_table}{Hash\+Table} class.

This function will loop from index 0 to the size of the table\+Size. In the loop the function checks each index/\+Binary Search Tree and checks if it is Empty or not. This does this by calling the is\+Empty function for the B\+ST. The function returns false it isn\textquotesingle{}t, otherwise the function returns true if all of it is cleared.


\begin{DoxyParams}{Parameters}
{\em none} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function returns true if the \hyperlink{class_hash_table}{Hash\+Table} is empty, otherwise it returns false.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
An \hyperlink{class_hash_table}{Hash\+Table} object. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
Returns true if the \hyperlink{class_hash_table}{Hash\+Table} is empty, otherwise it returns false. 
\end{DoxyPostcond}
\index{Hash\+Table@{Hash\+Table}!operator=@{operator=}}
\index{operator=@{operator=}!Hash\+Table@{Hash\+Table}}
\paragraph[{\texorpdfstring{operator=(const Hash\+Table \&other)}{operator=(const HashTable &other)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type , typename Key\+Type $>$ {\bf Hash\+Table}$<$ Data\+Type, Key\+Type $>$ \& {\bf Hash\+Table}$<$ Data\+Type, Key\+Type $>$\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Hash\+Table}$<$ Data\+Type, Key\+Type $>$ \&}]{other}
\end{DoxyParamCaption}
)}\hypertarget{class_hash_table_add76a73a92b81a2d54c20078d4a76546}{}\label{class_hash_table_add76a73a92b81a2d54c20078d4a76546}
This function is the overloaded assignment operator for the \hyperlink{class_hash_table}{Hash\+Table} class.

This function will check if the current object is not the other parameter. Then the function will first clear the object. This function will then call the copy\+Table function with other passed in as the parameter to create a copy of the other \hyperlink{class_hash_table}{Hash\+Table}.


\begin{DoxyParams}{Parameters}
{\em const} & Hash\+Table$<$\+Data\+Type, Key\+Type$>$\& other, which is the other \hyperlink{class_hash_table}{Hash\+Table} that is to be copied so that this object is the copy of the other./ \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function returns a pointer to this object.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
none 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
This function will create a copy of the parameter of \hyperlink{class_hash_table}{Hash\+Table}\& other and make the copy to this object. 
\end{DoxyPostcond}
\index{Hash\+Table@{Hash\+Table}!remove@{remove}}
\index{remove@{remove}!Hash\+Table@{Hash\+Table}}
\paragraph[{\texorpdfstring{remove(const Key\+Type \&delete\+Key)}{remove(const KeyType &deleteKey)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type , typename Key\+Type $>$ bool {\bf Hash\+Table}$<$ Data\+Type, Key\+Type $>$\+::remove (
\begin{DoxyParamCaption}
\item[{const Key\+Type \&}]{delete\+Key}
\end{DoxyParamCaption}
)}\hypertarget{class_hash_table_a46d3f8ad70fd80dc7aa64f50676ef7a5}{}\label{class_hash_table_a46d3f8ad70fd80dc7aa64f50676ef7a5}
This function is the remove function for the \hyperlink{class_hash_table}{Hash\+Table} class, which removes a delete\+Key from the \hyperlink{class_hash_table}{Hash\+Table}.

This function loops from index 0 to the size of the table\+Size. In this for loop, the function checks to see if the delete\+Key is removed from the \hyperlink{class_hash_table}{Hash\+Table}. the function does this by looping until the \hyperlink{class_hash_table}{Hash\+Table} is able to do this by calling the remove function from the Binary Search Tree A\+DT with the delete\+Key passed as the parameter. If that statement is true, the function returns true. If that statement is not true and the for loop ends. The function returns false since the Key was never found or deleted.


\begin{DoxyParams}{Parameters}
{\em const} & Key\+Type\& delete\+Key, which is the Key passed by reference to be deleted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function returns true if the Key\+Type was removed successfully from the \hyperlink{class_hash_table}{Hash\+Table}.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
A \hyperlink{class_hash_table}{Hash\+Table} object to be modified. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The delete\+Key of the same value in the \hyperlink{class_hash_table}{Hash\+Table} will be deleted. 
\end{DoxyPostcond}
\index{Hash\+Table@{Hash\+Table}!retrieve@{retrieve}}
\index{retrieve@{retrieve}!Hash\+Table@{Hash\+Table}}
\paragraph[{\texorpdfstring{retrieve(const Key\+Type \&search\+Key, Data\+Type \&return\+Item) const }{retrieve(const KeyType &searchKey, DataType &returnItem) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type , typename Key\+Type $>$ bool {\bf Hash\+Table}$<$ Data\+Type, Key\+Type $>$\+::retrieve (
\begin{DoxyParamCaption}
\item[{const Key\+Type \&}]{search\+Key, }
\item[{Data\+Type \&}]{return\+Item}
\end{DoxyParamCaption}
) const}\hypertarget{class_hash_table_ad4ee3ff641daa330260a48de29492e66}{}\label{class_hash_table_ad4ee3ff641daa330260a48de29492e66}
This function is the retrieve function for the \hyperlink{class_hash_table}{Hash\+Table} class, which copies the data\+Item to search\+Data\+Item and returns true.

This function will loop from index 0 to the size of the table\+Size. In this for loop, the function checks to see if the Search\+Key is found in the \hyperlink{class_hash_table}{Hash\+Table}. The function does this by checking the binary tree of each index to see if the search\+Key is found in there. It does that by calling the retrieve function from the Binary Search Tree A\+DT of each index with the parameters of search\+Key and return\+Item passed as the parameters. The function checks to see if that process will return true. If it does, the function itself returns true. If the for loop ends and that process is never true, the function will return false.


\begin{DoxyParams}{Parameters}
{\em const} & Key\+Type\& search\+Key, which is the Key\+Type to be found in the \hyperlink{class_hash_table}{Hash\+Table}. \\
\hline
{\em const} & Data\+Type\& search\+Data\+Item, which holds the copied data of the search\+Key if it is found. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does returns true or false, based on if the function data\+Item is found.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
A \hyperlink{class_hash_table}{Hash\+Table} object. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
search\+Data\+Item contains the data of the search\+Key if the search\+Key was found. 
\end{DoxyPostcond}
\index{Hash\+Table@{Hash\+Table}!show\+Structure@{show\+Structure}}
\index{show\+Structure@{show\+Structure}!Hash\+Table@{Hash\+Table}}
\paragraph[{\texorpdfstring{show\+Structure() const }{showStructure() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type , typename Key\+Type $>$ void {\bf Hash\+Table}$<$ Data\+Type, Key\+Type $>$\+::show\+Structure (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_hash_table_a8b875e57f71a5bbba394e42361fb9fb4}{}\label{class_hash_table_a8b875e57f71a5bbba394e42361fb9fb4}
This function is the show\+Structure function for the \hyperlink{class_hash_table}{Hash\+Table} class

The function will iterate through the loop, and print out the indexes of the \hyperlink{class_hash_table}{Hash\+Table}.


\begin{DoxyParams}{Parameters}
{\em none} & \\
\hline
{\em } & \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Hash\+Table.\+h\item 
\hyperlink{_hash_table_8cpp}{Hash\+Table.\+cpp}\item 
show10.\+cpp\end{DoxyCompactItemize}

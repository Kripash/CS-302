\hypertarget{_rush_hour_8cpp}{}\subsection{Rush\+Hour.\+cpp File Reference}
\label{_rush_hour_8cpp}\index{Rush\+Hour.\+cpp@{Rush\+Hour.\+cpp}}
{\ttfamily \#include $<$iostream$>$}\\*
{\ttfamily \#include $<$map$>$}\\*
{\ttfamily \#include $<$queue$>$}\\*
{\ttfamily \#include $<$string$>$}\\*
\subsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{class_board}{Board}
\item 
class \hyperlink{class_board_1_1_car}{Board\+::\+Car}
\end{DoxyCompactItemize}
\subsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{_rush_hour_8cpp_a03450682e7fd05eadf4f39c3a2b105ad}{Solve\+It} ()
\item 
int \hyperlink{_rush_hour_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}{main} ()
\end{DoxyCompactItemize}


\subsubsection{Function Documentation}
\index{Rush\+Hour.\+cpp@{Rush\+Hour.\+cpp}!main@{main}}
\index{main@{main}!Rush\+Hour.\+cpp@{Rush\+Hour.\+cpp}}
\paragraph[{\texorpdfstring{main()}{main()}}]{\setlength{\rightskip}{0pt plus 5cm}int main (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{_rush_hour_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}{}\label{_rush_hour_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}
\index{Rush\+Hour.\+cpp@{Rush\+Hour.\+cpp}!Solve\+It@{Solve\+It}}
\index{Solve\+It@{Solve\+It}!Rush\+Hour.\+cpp@{Rush\+Hour.\+cpp}}
\paragraph[{\texorpdfstring{Solve\+It()}{SolveIt()}}]{\setlength{\rightskip}{0pt plus 5cm}int Solve\+It (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{_rush_hour_8cpp_a03450682e7fd05eadf4f39c3a2b105ad}{}\label{_rush_hour_8cpp_a03450682e7fd05eadf4f39c3a2b105ad}
This is the free function Solve\+It.

This creates a board based on user setup and solves the board using the least amount of move possible, returning this value to the main function. It uses a queue to iterate through board configurations and a map to check if specific configurations have already been seen. Once the board is set up, it is pushed onto the queue. While the queue is not empty it will continue to find a solution. Once in the while loop it first sets the rush\+Hour board to the first board on the queue, then pops the queue If the board is solved it returns the number of moves to main. Otherwise it begins a for loop that will iterate though every vehical on the board. In the for loop it first checks if the vehical indicated by the index can move forward, moving forward if it can. If it moves forward, it then checks the map to see if the board has been seen before. If not, it increments the number of moves, adds the board to the map, adds the board to the queue, then decrements the number of moves. It then checks if the vehical indicated by the index can move backward, moving backward if it can. If it moves backward, it then checks the map to see if the board has been seen before. If not, it increments the number of moves, adds the board to the map, adds the board to the queue, then decrements the number of moves. The for loop then reapeats. Once the for loop finishes, the while loop loops again.


\begin{DoxyParams}{Parameters}
{\em N\+O\+NE} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function returns an integer which indicates the minimumn number of moves to solve a board.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Function is called to solve a board the user will input. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
A board is set up and the minimum number of moves to solve the board is found and returned. 
\end{DoxyPostcond}

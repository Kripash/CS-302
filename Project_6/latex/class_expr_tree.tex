\hypertarget{class_expr_tree}{}\subsection{Expr\+Tree$<$ Data\+Type $>$ Class Template Reference}
\label{class_expr_tree}\index{Expr\+Tree$<$ Data\+Type $>$@{Expr\+Tree$<$ Data\+Type $>$}}
\subsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node}
\end{DoxyCompactItemize}
\subsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_expr_tree_a1d5004443b461637bcb0fe0a86759d50}{Expr\+Tree} ()
\item 
\hyperlink{class_expr_tree_aeec9dc6139cf32fcc911840bab438239}{Expr\+Tree} (const \hyperlink{class_expr_tree}{Expr\+Tree} \&source)
\item 
\hyperlink{class_expr_tree}{Expr\+Tree} \& \hyperlink{class_expr_tree_a9a7b2120af2c2df666b1154eec20008a}{operator=} (const \hyperlink{class_expr_tree}{Expr\+Tree} \&source)
\item 
\hyperlink{class_expr_tree_a8976e9af7e1209b9db475b863ab9f31d}{$\sim$\+Expr\+Tree} ()
\item 
void \hyperlink{class_expr_tree_a283a61049eb163f6f370d562cc92c824}{build} ()
\item 
void \hyperlink{class_expr_tree_ac367645dc4ccaf488e121cd5a0a8c07d}{expression} () const 
\item 
Data\+Type \hyperlink{class_expr_tree_ad1579e64d55cdfcd500a634ef69ed792}{evaluate} () const   throw (logic\+\_\+error)
\item 
void \hyperlink{class_expr_tree_a87d6593a3ad6199b5521f6d1e3ba851f}{clear} ()
\item 
void \hyperlink{class_expr_tree_a8bfcf0da6dfd93f4228a35cded704fb4}{commute} ()
\item 
bool \hyperlink{class_expr_tree_ae64a4e3b5008fa2f533fd7461ead2485}{is\+Equivalent} (const \hyperlink{class_expr_tree}{Expr\+Tree} \&source) const 
\item 
void \hyperlink{class_expr_tree_a6f4c5e2ae8224fb53fb893231814e6d9}{show\+Structure} () const 
\end{DoxyCompactItemize}
\subsubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_expr_tree_ac34ce3b5c63b2094d66d4387f711a852}{insert} (\hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} $\ast$\&current, \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} $\ast$source)
\item 
void \hyperlink{class_expr_tree_afd8b4649b3a71b725c242dcec514b774}{build\+Helper} (\hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} $\ast$\&node)
\item 
void \hyperlink{class_expr_tree_af44ca51709f3691e1b2906ffeb3a4c14}{expression\+Helper} (const \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} $\ast$current) const 
\item 
Data\+Type \hyperlink{class_expr_tree_ae62e9cbcdc0d64772271595e457e4a6e}{evaluate\+Helper} (const \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} $\ast$current) const 
\item 
void \hyperlink{class_expr_tree_a00a0f8c3f062b6cacae2a81ce5245539}{clear\+Helper} (\hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} $\ast$\&current)
\item 
void \hyperlink{class_expr_tree_aaff3f1682720c5285d7ee9277002596c}{commute\+Helper} (\hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} $\ast$\&current)
\item 
bool \hyperlink{class_expr_tree_a6c35a0a2ad1ca4b9ba507cb09b5b0d05}{is\+Equivalent\+Helper} (\hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} $\ast$current, \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} $\ast$other) const 
\item 
void \hyperlink{class_expr_tree_a4a1342f4e255e1cc89bca07da2bc84cf}{show\+Helper} (\hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} $\ast$current, int level) const 
\end{DoxyCompactItemize}
\subsubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} $\ast$ {\bfseries root}\hypertarget{class_expr_tree_aad96de2c7df7ed8f49a87c7aa1b61e8f}{}\label{class_expr_tree_aad96de2c7df7ed8f49a87c7aa1b61e8f}

\end{DoxyCompactItemize}


\subsubsection{Constructor \& Destructor Documentation}
\index{Expr\+Tree@{Expr\+Tree}!Expr\+Tree@{Expr\+Tree}}
\index{Expr\+Tree@{Expr\+Tree}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{Expr\+Tree()}{ExprTree()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ {\bf Expr\+Tree}$<$ Data\+Type $>$\+::{\bf Expr\+Tree} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_expr_tree_a1d5004443b461637bcb0fe0a86759d50}{}\label{class_expr_tree_a1d5004443b461637bcb0fe0a86759d50}
This function is the default constructor for the Expr Tree class

This function will set the root of the \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} Class of the \hyperlink{class_expr_tree}{Expr\+Tree} Class to N\+U\+LL.


\begin{DoxyParams}{Parameters}
{\em none} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
The \hyperlink{class_expr_tree}{Expr\+Tree} is empty and was just created or needs to be modified. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The \hyperlink{class_expr_tree}{Expr\+Tree} will not have the \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} root set to N\+U\+LL 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!Expr\+Tree@{Expr\+Tree}}
\index{Expr\+Tree@{Expr\+Tree}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{Expr\+Tree(const Expr\+Tree \&source)}{ExprTree(const ExprTree &source)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ {\bf Expr\+Tree}$<$ Data\+Type $>$\+::{\bf Expr\+Tree} (
\begin{DoxyParamCaption}
\item[{const {\bf Expr\+Tree}$<$ Data\+Type $>$ \&}]{source}
\end{DoxyParamCaption}
)}\hypertarget{class_expr_tree_aeec9dc6139cf32fcc911840bab438239}{}\label{class_expr_tree_aeec9dc6139cf32fcc911840bab438239}
This function is the copy constructor for the \hyperlink{class_expr_tree}{Expr\+Tree} class.

This function will first set the root to N\+U\+LL and then call the recursive function insert, with the parameters as root of the class and source.\+root.


\begin{DoxyParams}{Parameters}
{\em \hyperlink{class_expr_tree}{Expr\+Tree}} & \&source, which takes a \hyperlink{class_expr_tree}{Expr\+Tree} by reference so that it can be used to copy the expression tree from the source to this object. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
none 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
This function will create a copy of the parameter of \hyperlink{class_expr_tree}{Expr\+Tree}\& source and make the copy to this object. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!````~Expr\+Tree@{$\sim$\+Expr\+Tree}}
\index{````~Expr\+Tree@{$\sim$\+Expr\+Tree}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{$\sim$\+Expr\+Tree()}{~ExprTree()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ {\bf Expr\+Tree}$<$ Data\+Type $>$\+::$\sim${\bf Expr\+Tree} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_expr_tree_a8976e9af7e1209b9db475b863ab9f31d}{}\label{class_expr_tree_a8976e9af7e1209b9db475b863ab9f31d}
This function is the destructor for the \hyperlink{class_expr_tree}{Expr\+Tree} class.

This function will call the clear function to dynamically deallocate the memory for the current object.


\begin{DoxyParams}{Parameters}
{\em none} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
An Exprtree object. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
This function will be cleared through dynamically memory allocation. 
\end{DoxyPostcond}


\subsubsection{Member Function Documentation}
\index{Expr\+Tree@{Expr\+Tree}!build@{build}}
\index{build@{build}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{build()}{build()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ void {\bf Expr\+Tree}$<$ Data\+Type $>$\+::build (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_expr_tree_a283a61049eb163f6f370d562cc92c824}{}\label{class_expr_tree_a283a61049eb163f6f370d562cc92c824}
This function is the build function for the \hyperlink{class_expr_tree}{Expr\+Tree} class.

This function will call the build\+Helper function for to build the \hyperlink{class_expr_tree}{Expr\+Tree}.


\begin{DoxyParams}{Parameters}
{\em none} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
An \hyperlink{class_expr_tree}{Expr\+Tree} object that needs to be built. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
This function will build an \hyperlink{class_expr_tree}{Expr\+Tree} that is inputted to the terminal. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!build\+Helper@{build\+Helper}}
\index{build\+Helper@{build\+Helper}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{build\+Helper(\+Expr\+Tree\+Node $\ast$\&node)}{buildHelper(ExprTreeNode *&node)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ void {\bf Expr\+Tree}$<$ Data\+Type $>$\+::build\+Helper (
\begin{DoxyParamCaption}
\item[{{\bf Expr\+Tree\+Node} $\ast$\&}]{node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_expr_tree_afd8b4649b3a71b725c242dcec514b774}{}\label{class_expr_tree_afd8b4649b3a71b725c242dcec514b774}
This function is the build\+Helper function for the \hyperlink{class_expr_tree}{Expr\+Tree} class.

This function will create a location character called temp and cin to the temp. The function will then create a new \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} with the parameters of the param constructor as the char temp, N\+U\+LL and N\+U\+LL. The function will then check to see if Temp was equal to the operators +,-\/,$\ast$ and /. If it is, then the function will recursively call build\+Helper function twice with the parameters, as node -\/$>$ left and node-\/$>$ right.


\begin{DoxyParams}{Parameters}
{\em Expr\+Tree\+Node$\ast$\&} & node, an \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} pointer by reference so that it can be modified to build. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
An \hyperlink{class_expr_tree}{Expr\+Tree} object that needs to be built. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
This function will build an \hyperlink{class_expr_tree}{Expr\+Tree} that is inputted to the terminal. The function will call itself, if the char from the terminal is an operator, since it assums that operations has to be done, and if there isnt then we assume the char is a number and there is no operation left to do. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!clear@{clear}}
\index{clear@{clear}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{clear()}{clear()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ void {\bf Expr\+Tree}$<$ Data\+Type $>$\+::clear (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_expr_tree_a87d6593a3ad6199b5521f6d1e3ba851f}{}\label{class_expr_tree_a87d6593a3ad6199b5521f6d1e3ba851f}
This function is the clear function for the Expr Tree class

The function checks to see that the root is not N\+U\+LL, so that it can clear the expression tree. This function will call the clear\+Helper function with root passed as parameter to dynamically deallocate the expression tree. The function then sets the root equal to N\+U\+LL, just to double check.


\begin{DoxyParams}{Parameters}
{\em none} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
An expression tree object. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The \hyperlink{class_expr_tree}{Expr\+Tree} will be dynamically deallocated and cleared. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!clear\+Helper@{clear\+Helper}}
\index{clear\+Helper@{clear\+Helper}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{clear\+Helper(\+Expr\+Tree\+Node $\ast$\&current)}{clearHelper(ExprTreeNode *&current)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ void {\bf Expr\+Tree}$<$ Data\+Type $>$\+::clear\+Helper (
\begin{DoxyParamCaption}
\item[{{\bf Expr\+Tree\+Node} $\ast$\&}]{current}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_expr_tree_a00a0f8c3f062b6cacae2a81ce5245539}{}\label{class_expr_tree_a00a0f8c3f062b6cacae2a81ce5245539}
This function is the clear\+Helper function for the Expr Tree class

The function checks to make sure that the current \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} pointer passed by reference\textquotesingle{}s left is not N\+U\+LL. If it is not Null, the function will call itself with the parameters of current -\/$>$ left. The function repeats the same process for current -\/$>$ right. The function will then delete current and then set it to N\+U\+LL.


\begin{DoxyParams}{Parameters}
{\em Expr\+Tree\+Node$\ast$\&} & current, \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} pointer passed by reference to modify so that it may be dynamically deleted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
An expression tree object. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The \hyperlink{class_expr_tree}{Expr\+Tree} will be dynamically deallocated and cleared and call itself. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!commute@{commute}}
\index{commute@{commute}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{commute()}{commute()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ void {\bf Expr\+Tree}$<$ Data\+Type $>$\+::commute (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_expr_tree_a8bfcf0da6dfd93f4228a35cded704fb4}{}\label{class_expr_tree_a8bfcf0da6dfd93f4228a35cded704fb4}
This function is the commute function for the Expr Tree class

The \hyperlink{class_expr_tree}{Expr\+Tree} will call the commute\+Helper function with root passed as the parameter.


\begin{DoxyParams}{Parameters}
{\em none} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
none 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The \hyperlink{class_expr_tree}{Expr\+Tree} will call the commute\+Helper function with root passed as the parameter. This is to commute the oeprands for every arithmetic operating in the expression tree. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!commute\+Helper@{commute\+Helper}}
\index{commute\+Helper@{commute\+Helper}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{commute\+Helper(\+Expr\+Tree\+Node $\ast$\&current)}{commuteHelper(ExprTreeNode *&current)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ void {\bf Expr\+Tree}$<$ Data\+Type $>$\+::commute\+Helper (
\begin{DoxyParamCaption}
\item[{{\bf Expr\+Tree\+Node} $\ast$\&}]{current}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_expr_tree_aaff3f1682720c5285d7ee9277002596c}{}\label{class_expr_tree_aaff3f1682720c5285d7ee9277002596c}
This function is the commute\+Helper function for the Expr Tree class

The \hyperlink{class_expr_tree}{Expr\+Tree} will first check to see if the passed parameter current is not N\+U\+LL. If it is not, the function will then declare and initialize a \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} pointer called temp to current -\/$>$ left. The function will then set current -\/$>$ left to current -\/$>$ right. The function will then set current -\/$>$ right to temp. The function will then recursively call itself with current -\/$>$ left and current -\/$>$ right as the parameters.


\begin{DoxyParams}{Parameters}
{\em Expr\+Tree\+Node$\ast$\&} & current, which is the current tree node that the function will go through to commute. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
none 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The \hyperlink{class_expr_tree}{Expr\+Tree} will call the commute\+Helper function with root passed as the parameter. This is to commute the oeprands for every arithmetic operating in the expression tree. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!evaluate@{evaluate}}
\index{evaluate@{evaluate}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{evaluate() const }{evaluate() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ Data\+Type {\bf Expr\+Tree}$<$ Data\+Type $>$\+::evaluate (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const throw  logic\+\_\+error) }\hypertarget{class_expr_tree_ad1579e64d55cdfcd500a634ef69ed792}{}\label{class_expr_tree_ad1579e64d55cdfcd500a634ef69ed792}
This function is the evaluate function for the \hyperlink{class_expr_tree}{Expr\+Tree} class.

This function will first check to see if the root of the object is N\+U\+LL, if it is, we throw a logic error. If the root is not N\+U\+LL , then we call the evaluate\+Helper function with root as the passed parameter.


\begin{DoxyParams}{Parameters}
{\em none} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function returns the evaluate\+Helper function with root as the passed parameter.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
The object should not be an empty tree. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
This function will recursively evaluate the expression of the \hyperlink{class_expr_tree}{Expr\+Tree}. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!evaluate\+Helper@{evaluate\+Helper}}
\index{evaluate\+Helper@{evaluate\+Helper}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{evaluate\+Helper(const Expr\+Tree\+Node $\ast$current) const }{evaluateHelper(const ExprTreeNode *current) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ Data\+Type {\bf Expr\+Tree}$<$ Data\+Type $>$\+::evaluate\+Helper (
\begin{DoxyParamCaption}
\item[{const {\bf Expr\+Tree\+Node} $\ast$}]{current}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_expr_tree_ae62e9cbcdc0d64772271595e457e4a6e}{}\label{class_expr_tree_ae62e9cbcdc0d64772271595e457e4a6e}
This function is the evaluate\+Helper function for the \hyperlink{class_expr_tree}{Expr\+Tree} class.

This function will create a local char temp which will have current node -\/$>$ data\+Item. The function will then create a Data\+Type holder variable. The function will switch the char temp to evaluate the expression.\+If temp is a number between 0 and 9, the function will hold the datatype in the holder and convert it by subtractin \textquotesingle{}0\textquotesingle{} from it and then return the holder variable. If the operator is a \textquotesingle{}+\textquotesingle{}, the function will call itself with the current -\/$>$ left + current -\/$>$ right passed in as parameters to evaluate it. If the operator is a \textquotesingle{}-\/\textquotesingle{}, the function will call itself with the current-\/$>$ left -\/ current -\/$>$ right passed in as parameters to evaluate it. If the operator is a \textquotesingle{}$\ast$\textquotesingle{}, the function will call itself with the current-\/$>$ left $\ast$ current -\/$>$ right passed in as parameters to evaluate it. If the operator is a \textquotesingle{}/\textquotesingle{}, the function will call itself with the current-\/$>$ left / current -\/$>$ right passed in as parameters to evaluate it.


\begin{DoxyParams}{Parameters}
{\em const} & Expr\+Tree\+Node$\ast$ current, which is the current Tree\+Node that will be observed, such as if it an operator or a number and so on. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function returns the evaluated expression based on the case statement that switches the char temp, which is the data\+Item of the current parameter.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
The object should not be an empty tree. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
This function will recursively evaluate the expression of the \hyperlink{class_expr_tree}{Expr\+Tree}. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!expression@{expression}}
\index{expression@{expression}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{expression() const }{expression() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ void {\bf Expr\+Tree}$<$ Data\+Type $>$\+::expression (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_expr_tree_ac367645dc4ccaf488e121cd5a0a8c07d}{}\label{class_expr_tree_ac367645dc4ccaf488e121cd5a0a8c07d}
This function is the expression function for the \hyperlink{class_expr_tree}{Expr\+Tree} class.

This function will check to see if the root of the \hyperlink{class_expr_tree}{Expr\+Tree} is not N\+U\+L\+L.\+If the \hyperlink{class_expr_tree}{Expr\+Tree} is not N\+U\+LL, the function will call the expression\+Helper function with the parameter passed as the root.


\begin{DoxyParams}{Parameters}
{\em none} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
An \hyperlink{class_expr_tree}{Expr\+Tree} that is not empty. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
This function will call the expression\+Helper function to print out the expression of the \hyperlink{class_expr_tree}{Expr\+Tree}. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!expression\+Helper@{expression\+Helper}}
\index{expression\+Helper@{expression\+Helper}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{expression\+Helper(const Expr\+Tree\+Node $\ast$current) const }{expressionHelper(const ExprTreeNode *current) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ void {\bf Expr\+Tree}$<$ Data\+Type $>$\+::expression\+Helper (
\begin{DoxyParamCaption}
\item[{const {\bf Expr\+Tree\+Node} $\ast$}]{current}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_expr_tree_af44ca51709f3691e1b2906ffeb3a4c14}{}\label{class_expr_tree_af44ca51709f3691e1b2906ffeb3a4c14}
This function is the expression\+Helper function for the \hyperlink{class_expr_tree}{Expr\+Tree} class.

This function will create a local char variable called temp. Temp will be equal to the current -\/$>$ data\+Item. The function then checks, to see if the char contains a number between 0-\/9. If it is, it the prints out the char. If the char is not a number, then the function prints out the open parantheses first amd then recurssively calls itself twice with the parameters current -\/$>$ left and then cout the current -\/$>$ data\+Item and t the parameter current -\/$>$ right and then cout a close parantheses.


\begin{DoxyParams}{Parameters}
{\em const} & Expr\+Tree\+Node$\ast$ current, a \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} pointer that is used to start the recursion to print out the expression of the object. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
none. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
This function will recursively printout the expression of the \hyperlink{class_expr_tree}{Expr\+Tree}. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!insert@{insert}}
\index{insert@{insert}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{insert(\+Expr\+Tree\+Node $\ast$\&current, Expr\+Tree\+Node $\ast$source)}{insert(ExprTreeNode *&current, ExprTreeNode *source)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ void {\bf Expr\+Tree}$<$ Data\+Type $>$\+::insert (
\begin{DoxyParamCaption}
\item[{{\bf Expr\+Tree\+Node} $\ast$\&}]{current, }
\item[{{\bf Expr\+Tree\+Node} $\ast$}]{source}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_expr_tree_ac34ce3b5c63b2094d66d4387f711a852}{}\label{class_expr_tree_ac34ce3b5c63b2094d66d4387f711a852}
This function is the insert function for the \hyperlink{class_expr_tree}{Expr\+Tree} class, which is the helper function for the constructors for me.

This function will take in a pointer by reference and a pointer and take the source and modify the current to be the same as the soure. This is done by checking if the source is N\+U\+LL, if it is, then current is set to N\+U\+LL. If Source is not N\+U\+LL, then, we set the current with the \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} param constructor with source\textquotesingle{}s data\+Item and its left and right set to N\+U\+LL. I then recursively call the function till there is nothing left to insert, with current -\/$>$ left, source -\/$>$ left and current -\/$>$ right and source -\/$>$ right passed as the parameters.


\begin{DoxyParams}{Parameters}
{\em \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node}} & $\ast$\& current, which takes a Exp\+Tree\+Node pointer by reference so that it can be modified \\
\hline
{\em \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node}} & $\ast$source, which takes a \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} pointer so that it can be used to set the other pointer passed to be reference as. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
The Expr\+Tree\+Node$\ast$\&current is empty and was just created or needs to be copied from the Expr\+Tree\+Node$\ast$ Source 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The Expr\+Tree\+Node$\ast$\& current will have a copy of the function of Expr\+Tree\+Node$\ast$source. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!is\+Equivalent@{is\+Equivalent}}
\index{is\+Equivalent@{is\+Equivalent}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{is\+Equivalent(const Expr\+Tree \&source) const }{isEquivalent(const ExprTree &source) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ bool {\bf Expr\+Tree}$<$ Data\+Type $>$\+::is\+Equivalent (
\begin{DoxyParamCaption}
\item[{const {\bf Expr\+Tree}$<$ Data\+Type $>$ \&}]{source}
\end{DoxyParamCaption}
) const}\hypertarget{class_expr_tree_ae64a4e3b5008fa2f533fd7461ead2485}{}\label{class_expr_tree_ae64a4e3b5008fa2f533fd7461ead2485}
This function is the is\+Equivalent function for the Expr Tree class

The function will check to see if both the root of the current object and the source object are N\+U\+LL. If they are, the function will then check to see if they are equal. If they are, the function returns true, other wise it returns false. The function then checks to see if the current root-\/$>$data\+Item is equal to source.\+root -\/$>$ data\+Item, and if they are equal the function returns is\+Equivalent\+Helper with root and source.\+root passed as the parameters. Otherwise the function will return false.


\begin{DoxyParams}{Parameters}
{\em const} & \hyperlink{class_expr_tree}{Expr\+Tree}\& source, which is the other tree that the current object will be compared to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function returns either true of false, depending on if the expression tree computations are equal.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
none 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The \hyperlink{class_expr_tree}{Expr\+Tree} will call the commute\+Helper function with root passed as the parameter. This is to commute the oeprands for every arithmetic operating in the expression tree. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!is\+Equivalent\+Helper@{is\+Equivalent\+Helper}}
\index{is\+Equivalent\+Helper@{is\+Equivalent\+Helper}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{is\+Equivalent\+Helper(\+Expr\+Tree\+Node $\ast$current, Expr\+Tree\+Node $\ast$other) const }{isEquivalentHelper(ExprTreeNode *current, ExprTreeNode *other) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ bool {\bf Expr\+Tree}$<$ Data\+Type $>$\+::is\+Equivalent\+Helper (
\begin{DoxyParamCaption}
\item[{{\bf Expr\+Tree\+Node} $\ast$}]{current, }
\item[{{\bf Expr\+Tree\+Node} $\ast$}]{other}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_expr_tree_a6c35a0a2ad1ca4b9ba507cb09b5b0d05}{}\label{class_expr_tree_a6c35a0a2ad1ca4b9ba507cb09b5b0d05}
This function is the is\+Equivalent\+Helper function for the Expr Tree class

The function first declares and intializes a local char temp variable to current -\/$>$ data\+Item. The function then creates local char variables called left and right. The function will check to see if the temp is a number between 0 and 9, and then if it is, it makes to sure that the two nodes passed, have the same data\+Item and then return true if that is the case and return false if that is not the case. The function assigns left and right to current -\/$>$ left -\/$>$ data\+Item and current -\/$>$ right -\/$>$data\+Item. The function then checks to see if either left or right is an operator. If so, it goes to make sure that left and right are equal to other -\/$>$ left -\/$>$ data\+Item and other -\/$>$ right -\/$>$ data\+Item. If that is true, then the function will return itself with current -\/$>$ left, other -\/$>$ left, current -\/$>$ right and other-\/$>$ right passed as parameters. The function also checks to make sure that the left of the current is equal to the right of the other and vice versa and does the same return call but with, current -\/$>$ left, other -\/$>$ right, current -\/$>$right and other -\/$>$ left respectively. The function then checks to see if temp is either a -\/ or /, since 1-\/2 and 2-\/1, and 1/2 and 2/1 are different for example. The property wont apply to the two operator. So the function checks that and returns itself with the left and right data item of current and other to make sure that it is equal. Otherwise, it does the same check but with two cases, where (current -\/$>$ left -\/$>$ data\+Item, other -\/$>$ left -\/$>$ data\+Item, current -\/$>$ right -\/$>$ data\+Item and other -\/$>$ right data\+Item, are equal) or (current -\/$>$ left -\/$>$ data\+Item, other -\/$>$ right -\/$>$ data\+Item, current -\/$>$ right -\/$>$ data\+Item and other -\/$>$ left data\+Item, are equal


\begin{DoxyParams}{Parameters}
{\em Expr\+Tree\+Node$\ast$} & current, which is the current node that the function will look at and compare to the other. \\
\hline
{\em Expr\+Tree\+Node$\ast$} & other, which is the other node that the function will compare with to check if they are equal. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function returns either true of false, depending on if the expression tree computations are equal.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Two \hyperlink{class_expr_tree_1_1_expr_tree_node}{Expr\+Tree\+Node} pointers must be passed so that the entire tree traversal can be compared. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The function will go and traverse through the trees of both of Node representatives and check to see if they are equal and return true of false based on that. The function will call itself to check if certain cases are true or false and then return that. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!operator=@{operator=}}
\index{operator=@{operator=}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{operator=(const Expr\+Tree \&source)}{operator=(const ExprTree &source)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ {\bf Expr\+Tree}$<$ Data\+Type $>$ \& {\bf Expr\+Tree}$<$ Data\+Type $>$\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Expr\+Tree}$<$ Data\+Type $>$ \&}]{source}
\end{DoxyParamCaption}
)}\hypertarget{class_expr_tree_a9a7b2120af2c2df666b1154eec20008a}{}\label{class_expr_tree_a9a7b2120af2c2df666b1154eec20008a}
This function is the overloaded assignment operator for the \hyperlink{class_expr_tree}{Expr\+Tree} class.

This function will check if the current object is not the source parameter. The function will first clear the object, and then the root to N\+U\+LL and then call the recursive function insert, with the parameters as root of the class and source.\+root.


\begin{DoxyParams}{Parameters}
{\em Const} & \hyperlink{class_expr_tree}{Expr\+Tree} \&source, which takes a \hyperlink{class_expr_tree}{Expr\+Tree} by reference so that it can be used to copy the expression tree from the source to this object. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
An object that is not the same as the object that was passed as the parameter for the copy constructor. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
This function will create a copy of the parameter of \hyperlink{class_expr_tree}{Expr\+Tree}\& source and make the copy to this object. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!show\+Helper@{show\+Helper}}
\index{show\+Helper@{show\+Helper}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{show\+Helper(\+Expr\+Tree\+Node $\ast$current, int level) const }{showHelper(ExprTreeNode *current, int level) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ void {\bf Expr\+Tree}$<$ Data\+Type $>$\+::show\+Helper (
\begin{DoxyParamCaption}
\item[{{\bf Expr\+Tree\+Node} $\ast$}]{p, }
\item[{int}]{level}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_expr_tree_a4a1342f4e255e1cc89bca07da2bc84cf}{}\label{class_expr_tree_a4a1342f4e255e1cc89bca07da2bc84cf}
This function is the show\+Helper function for the Expr Tree class

The function will iterate through the loop, and print out the leaves and branches of the expression tree.


\begin{DoxyParams}{Parameters}
{\em Exp\+Tree\+Node} & $\ast$p, which is the node to start the printing at. \\
\hline
{\em int} & level, the level to start the printing of the trees and branches at. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
none 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The contents of the Expression\+Tree will be printed to the terminal in the way that it should be. 
\end{DoxyPostcond}
\index{Expr\+Tree@{Expr\+Tree}!show\+Structure@{show\+Structure}}
\index{show\+Structure@{show\+Structure}!Expr\+Tree@{Expr\+Tree}}
\paragraph[{\texorpdfstring{show\+Structure() const }{showStructure() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Data\+Type $>$ void {\bf Expr\+Tree}$<$ Data\+Type $>$\+::show\+Structure (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_expr_tree_a6f4c5e2ae8224fb53fb893231814e6d9}{}\label{class_expr_tree_a6f4c5e2ae8224fb53fb893231814e6d9}
This function is the show\+Structure function for the Expr Tree class

The function will make sure that the tree is not empty. If it is, the function will print empty tree. Other wise it will call the show\+Helper function with root, and 1 passed as the parameters.


\begin{DoxyParams}{Parameters}
{\em none} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This function does not return anything.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
none 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
The contents of the Expression\+Tree will be printed to the terminal in the way that it should be. 
\end{DoxyPostcond}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Expression\+Tree.\+h\item 
\hyperlink{_expression_tree_8cpp}{Expression\+Tree.\+cpp}\item 
show8.\+cpp\end{DoxyCompactItemize}
